<!--
DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.

This material is based upon work supported by the Department of the Air Force under Air Force Contract No. FA8702-15-D-0001. Any opinions, findings, conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Department of the Air Force.

Â© 2019 Massachusetts Institute of Technology.
 
Subject to FAR52.227-11 Patent Rights - Ownership by the contractor (May 2014)
 
The software/firmware is provided to you on an As-Is basis
 
Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part 252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed above. Use of this work other than as specifically authorized by the U.S. Government may violate any copyrights that exist in this work.
-->

# ooze

Ooze is a collection of modular mutation strategies for use in fuzz testing. Each strategy leverages one or more mutations to generate new inputs and is packaged as a shared library.

### Directory Structure

1. '/include' - the header files you need in order to use an Ooze module in your project.
2. '/strategies' - strategy and mutation code.

## Building

Assuming that you have installed the dependencies listed in the root README, the following command can be used to build ooze:

```shell script
mkdir build; cd build; CC=clang cmake ..; make; sudo make install;
```

## Usage:

Each Ooze strategy module provides a function `get_fuzzing_strategy()`. This function populates a `fuzzing_strategy` object (defined in 'ooze.h') that provides access to the API for a given strategy.

In order to use an ooze strategy, you must:

1. Call `dlopen()` to load the desired library.
2. Call the `get_fuzzing_strategy()` function to fill in a `fuzzing_strategy` object.
3. Use the `fuzzing_strategy` object to interface with the API.

Here is an example of performing these steps:

```c
// global
fuzzing_strategy *strategy;
...

// Load the fuzzer strategy .so file
handle = dlopen(argv[1], RTLD_LAZY);

char *error = dlerror();

// check that we can open the handle
if (error) {
	bail_out(error);
}

// Get a pointer to the "populate the fuzzing_strategy struct" function
get_fuzzing_strategy_function *get_fuzzing_strategy;
get_fuzzing_strategy = (get_fuzzing_strategy_function *)dlsym(handle, "get_fuzzing_strategy");

error = dlerror();

if (error) {
	bail_out(error);
}

// populate the fuzzing_strategy struct
(*get_fuzzing_strategy)(&strategy);

// Produce a seed value base on time-of-day
time_t = time(NULL);
struct tm tm = *localtime(&t);
char *seed;
asprintf(&seed, "&d%d%d\n", tm.tm_hour, tm.tm_min, tm.tm_sec);

// This will be our fuzzer-produced value used as an input to the progam-under-test
char fuzzer_value[8];

// Create and initialize a state object
strategy_state *strategy_state_ptr;
strategy_state_ptr = (*strategy.create_state)(seed, sizeof(fuzzer_value));

...
```

## The Ooze API

### API Variables

Each strategy exposes the following global variables:

```c
const char *name;
```
The name of the strategy.

```c
bool is_deterministic;
```  
TRUE if the given strategy is deterministic.

```c
const char *description;
```  

### API Functions

Each strategy provides the following functions:

#### create_state

```c
strategy_state *create_state(u8 *seed, size_t max_size, ...);
```
##### Description
Create a `strategy_state` object using the supplied `seed` string and `max_size`.

Returns a pointer to the newly allocated object.

Note that the `seed` string may or may not be used by a strategy but is typically used to seed pseudo-random number generators.

The `max_size` variable defines the maximum size of data generated by other functions.

Some strategies take additional arguments: 
  * `afl_dictionary_insert`
  * `afl_dictionary_create`
   
Others may rely on environment variables to share data:
  * `afl_dictionary`

#### mutate
```c
size_t mutate(u8 *buffer, size_t size, strategy_state *state);
```
##### Description

Mutate the supplied `buffer` of test data **in place** to produce a new buffer of test data.

* `buffer` - pointer to a buffer containing data to mutate.  
* `size` - size of `buffer` expressed in bytes.  
* `state` - pointer to `strategy_state` object.

Remember to make a copy of the data in buffer prior to calling mutate if you wish to preserve it!

The return value is the size of the now mutated data in the buffer.

1. The returned size will never be greater than `max_size` provided to `create_state()`.
2. mutate functions return zero when a mutation could not be performed.  
   * This can happen for various reasons:
      * A deterministic strategy is complete.
	  * The mutation would have resulted in a size greater than max_size.

#### serialize
```c
char *serialize(strategy_state *state);
```

##### Description

Serialize the supplied `strategy_state` object. Returns a pointer to the resulting ascii yaml string. The supplied `strategy_state` object is not freed.

#### deserialize
```c
strategy_state *deserialize(char *state);
```

##### Description
Given a serialized `strategy_state` object, returns a `strategy_state` object.

The serialized `strategy_state` is not freed.

#### print_state
```c
char *print_state(strategy_state *state);
```
##### Description
Return a human-readable (printable) description of a given `strategy_state` object.

This is mostly used for debugging.

#### copy_state
```c
strategy_state *copy_state(strategy_state *state);
```
##### Description
Copy a `strategy_state` object. A pointer is returned to the newly allocated copy.

#### free_state
```c
void free_state(strategy_state *state);
```
##### Description

Free the supplied given `strategy_state` object.

#### update_state
```c
void update_state(strategy_state *state);
```
##### Description
Update the supplied `strategy_state` object so that the `mutate()` function will not produce the same result.

## A Fuzzing Strategy

A `strategy_state` object contains state information for a given fuzzing strategy. It is passed as an argument to most functions exposed by the `fuzzing_strategy` object. These `strategy_state` objects are not interchangeable between strategies.

The mutate function is not necessarily deterministic. The user must update the `strategy_state` object by invoking the `update_state()` function after each call to the mutate function.

Typical Usage:

```c
// A struct containing the deserialized ooze state
strategy_state *deserialized_state = (*strategy.deserialize)(serial_state);

// The serialized ooze state, as a string
char *serialize_state = (*strategy.serialize)(deserialized_state);

...
size_t input_size = 4;
u8 * to_mutate = calloc(1, 8);
memcpy(to_mutate, "AAAA", input_size);

size_t mutated_size = (*strategy.mutate)(to_mutate, input_size, deserialized_state);

(strategy.update_state)(deserialized_state);

...
```

## Pseudo-random Number Generation

Ooze utilizes it's own pseudo-random number generator. This is because because different operating systems use different generators. We also only need statistical randomness, not cryptographic randomness.

## Notable Differences Between the Functionality of AFL and our AFL-based Strategies

1. Ooze has no concept of instrumentation. Instrumentation and evaluation of inputs must be done by whatever software is leveraging Ooze.
   * Auto token detection in single bit flip.
   * `afl_bit_flip` does not include single bit flip because of the auto token detection.
2. Effector maps have been dropped.

3. The `could_be_bitflip()` / `could_be_interesting()` / `could_be_arith()` functions have been ignored.

4. `afl_arith`: always generates an input. AFL does `two_byte_arith` and `four_byte_arith` selectively.
   * for `two_byte_arith`, if mutation changes more than one byte.
   * for `four_byte_arith`, if the mutation changes more than two bytes.
  
5. No `afl_splice` strategy exists.  
   * AFL's splice mode is effectively the same as havoc mode, except that two un-mutated inputs are spliced together before being passed to havoc.
   * We did not write an `afl_splice` strategy because of this.
   * Users should instead perform the splicing themselves and then invoke the `afl_havoc` strategy.
  
6. `afl_dictionary_overwrite`
   * Our dictionary objects hold a maximum number of tokens.
   * AFL's hold a lot of tokens, and probabilistically select tokens to use for mutations if there are more tokens than `MAX_TOKENS`.
  
7. `afl_havoc`
   * `afl_havoc` is an infinite strategy, producing a new input every time it is called. 
   * AFL runs havoc a fixed amount of times, using each newly generated input.
